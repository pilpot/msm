import{s as A,m as R,x as m,e as y,c as p,b,f as u,y as c,z as w,i as C,u as _,q as B,r as v,A as f,B as S}from"./scheduler.x4Pbowds.js";import{S as P,i as k,t as O,b as E}from"./index.v-92yLxh.js";import{c as g,g as I}from"./button.y0uZejvG.js";function G(h){let s,t,e;const i=h[3].default,o=R(i,h,h[2],null);let l=[{class:t=g(h[0])},h[1]],a={};for(let n=0;n<l.length;n+=1)a=m(a,l[n]);return{c(){s=y("h1"),o&&o.c(),this.h()},l(n){s=p(n,"H1",{class:!0});var r=b(s);o&&o.l(r),r.forEach(u),this.h()},h(){c(s,a),w(s,"svelte-9b0tta",!0)},m(n,r){C(n,s,r),o&&o.m(s,null),e=!0},p(n,[r]){o&&o.p&&(!e||r&4)&&_(o,i,n,n[2],e?v(i,n[2],r,null):B(n[2]),null),c(s,a=I(l,[(!e||r&1&&t!==(t=g(n[0])))&&{class:t},r&2&&n[1]])),w(s,"svelte-9b0tta",!0)},i(n){e||(O(o,n),e=!0)},o(n){E(o,n),e=!1},d(n){n&&u(s),o&&o.d(n)}}}function M(h,s,t){const e=["class"];let i=f(s,e),{$$slots:o={},$$scope:l}=s,{class:a=null}=s;return h.$$set=n=>{s=m(m({},s),S(n)),t(1,i=f(s,e)),"class"in n&&t(0,a=n.class),"$$scope"in n&&t(2,l=n.$$scope)},[a,i,l,o]}class q extends P{constructor(s){super(),k(this,s,M,G,A,{class:0})}}class V{allRemainingAnswers;allowDuplicates;answer;attempts;availableColors;board;colors;columns;guessAlgorithm;noConsoleOutput;remainingAnswersCount;maxAnswers;resolution;rows;status;constructor(s,t,e,i,o){this.columns=t??5,this.rows=e??10,this.colors=s??8,this.availableColors=Array.from({length:this.colors},(l,a)=>a+1),this.status="idle",this.board=Array(1).fill(null).map(()=>Array(this.colors).fill(null)),this.resolution=Array(1).fill(null).map(()=>Array(2).fill(0)),this.remainingAnswersCount=Array(this.rows).fill(0),this.answer=Array(this.columns).fill(0),this.allowDuplicates=i??!0,this.guessAlgorithm=o??"random",this.allRemainingAnswers=[],this.maxAnswers=0,this.noConsoleOutput=!1,this.attempts=0}addBoardRow(){this.board.push(Array(this.columns).fill(null))}addResolutionRow(){this.resolution.push([0,0])}setColors(s){this.colors=s,this.availableColors=Array.from({length:this.colors},(t,e)=>e+1)}async answerResolutionBoardAll(){for(let s=0;s<this.board.length;s++)await this.answerResolutionBoardRow(s)}async answerResolutionBoardRow(s){this.resolution[s]=await this.evaluateRow(this.board[s]),this.resolution[s][0]===0&&this.resolution[s][1]===this.columns?this.status="won":this.status="lost"}countLeastCommonColors(s,t){let e=0;for(let i=0;i<s.length;i++)s[i]===t[i]&&e++;return s.length-e}countSamePosition(s,t){let e=0;for(let i=0;i<s.length;i++)s[i]===t[i]&&e++;return e}async eliminateAnswers(s){if(this.board[s].every(i=>i===null))return;const t=this.resolution[s][1],e=this.resolution[s][0]+this.resolution[s][1];for(let i=0;i<this.allRemainingAnswers.length;i++){const o=this.allRemainingAnswers[i];let l=0,a=0;for(let n=0;n<this.columns;n++)o[n]===this.board[s][n]&&l++,o.includes(this.board[s][n])&&a++;l==t&&a>=e||(this.allRemainingAnswers.splice(i,1),i--)}this.remainingAnswersCount[s]=this.allRemainingAnswers.length}async eliminateAnswersAll(){for(let s=0;s<this.board.length;s++)await this.eliminateAnswers(s)}async evaluateRow(s){let t=0,e=0;const i=new Set(this.answer);for(let o=0;o<this.columns;o++)s[o]!==this.answer[o]?i.has(s[o])&&t++:e++;return[t,e]}findOptimalAnswer(){let s=this.allRemainingAnswers[0],t=this.allRemainingAnswers[0].length;for(let e=0;e<this.allRemainingAnswers.length;e++){const i=this.allRemainingAnswers[e];let o=0;for(let l=0;l<this.columns;l++)i[l]===this.answer[l]&&o++;o<t&&(t=o,s=i)}return s}async generateAllPossibleAnswers(s){const t=[...this.availableColors],e=[];if(s){const i=(o,l)=>{if(o.length===this.columns){e.push(o);return}for(let a=0;a<l.length;a++){const n=l[a];i([...o,n],l)}};i([],t)}else{const i=(o,l)=>{if(o.length===this.columns){e.push(o);return}for(let a=0;a<l.length;a++){const n=l[a],r=l.filter((x,d)=>d!==a);i([...o,n],r)}};i([],t)}return e.push([8,7,6,5,4]),e}generateRandomRow(s){s===void 0&&(s=this.allowDuplicates);const t=[...this.availableColors],e=[];if(s)for(let i=0;i<this.columns;i++){const o=Math.floor(Math.random()*t.length);e[i]=t[o]}else for(let i=0;i<this.columns;i++){const o=Math.floor(Math.random()*t.length);e[i]=t.splice(o,1)[0]}return e}async makeATry(){let s=-1;for(let t=0;t<this.rows;t++)if(this.board[t].every(e=>e===null)){s=t;break}if(s==-1)throw new Error("No empty row in the board");if(s==0){const t=this.generateRandomRow(this.allowDuplicates);await this.setBoardRow(s,t),this.removeAnswer(t)}else if(this.guessAlgorithm==="first"&&this.allRemainingAnswers.length>0){const t=this.allRemainingAnswers[0];await this.setBoardRow(s,t),this.removeAnswer(t)}else if(this.guessAlgorithm==="random"&&this.allRemainingAnswers.length>0){const t=Math.floor(Math.random()*this.allRemainingAnswers.length),e=this.allRemainingAnswers[t];await this.setBoardRow(s,e),this.removeAnswer(e)}else if(this.guessAlgorithm==="optimal"){const t=this.findOptimalAnswer();await this.setBoardRow(s,t)}else this.guessAlgorithm==="moreBlacks"?(this.allRemainingAnswers=this.sortBySamePosition(this.board[s-1],this.allRemainingAnswers),await this.setBoardRow(s,this.allRemainingAnswers[0]),this.removeAnswer(this.allRemainingAnswers[0])):this.guessAlgorithm==="lessWhites"&&(this.allRemainingAnswers=this.sortByLeastCommonColors(this.board[s-1],this.allRemainingAnswers),await this.setBoardRow(s,this.allRemainingAnswers[0]),this.removeAnswer(this.allRemainingAnswers[0]));return await this.answerResolutionBoardRow(s),await this.eliminateAnswers(s),this.resolution[s][1]==this.columns?(await this.outputBoard(),!0):(this.board.length<this.rows&&(this.addBoardRow(),this.addResolutionRow()),!1)}async outputBoard(s){if(s||!this.noConsoleOutput){console.log(this.answer);for(let t=0;t<this.board.length;t++)console.log(this.board[t],this.resolution[t],this.remainingAnswersCount[t]||"");console.log("--------------------")}}removeAnswer(s){if(this.allRemainingAnswers.length>1){const t=this.allRemainingAnswers.indexOf(s);this.allRemainingAnswers.splice(t,1)}}resetGame=()=>{this.status="idle",this.attempts=0,this.board=Array(1).fill(null).map(()=>Array(this.colors).fill(null)),this.resolution=Array(1).fill(null).map(()=>Array(2).fill(0)),this.remainingAnswersCount=Array(this.rows).fill(0),this.answer=Array(this.columns).fill(0)};runGameSequence=async()=>{for(this.resetGame(),this.status="playing",this.noConsoleOutput||console.log("\x1B[32mStarting game sequence...\x1B[0m"),await this.setAnswer(),await this.setAllRemainingAnswers(this.allowDuplicates),this.noConsoleOutput||console.log("Colors count: ",this.colors," Columns count: ",this.columns," Max Rows count: ",this.rows),this.noConsoleOutput||console.log("Guess algorithm: ",this.guessAlgorithm),this.noConsoleOutput||console.log("Starting answers count: ",this.allRemainingAnswers.length);this.attempts<this.rows&&this.resolution[this.attempts][1]<this.columns;){if(!this.allRemainingAnswers.some(s=>s.every((t,e)=>t===this.answer[e])))throw new Error("Answer has been erroneously eliminated from remaining answers, answer: "+this.answer);if(await this.makeATry())break;this.attempts++}this.noConsoleOutput||console.log("Game solved in ",this.attempts+1," tries, result:",this.status)};async setAllRemainingAnswers(s){s||(s=this.allowDuplicates),this.allRemainingAnswers=await this.generateAllPossibleAnswers(s),this.maxAnswers=this.allRemainingAnswers.length}async setAnswer(s){s?(await this.checkGuessIsValid(s),this.answer=s):this.answer=this.generateRandomRow(this.allowDuplicates)}async loadBoard(s){if(s.forEach((t,e)=>{if(t.length!==this.columns)throw new Error("Board row "+e+" must have "+this.columns+" colors")}),s.length>this.rows)throw new Error("Board must have "+this.rows+" rows");this.board=s}async checkGuessIsValid(s){if(!s.every(t=>t>=1&&t<this.colors+1))throw new Error("Nice try, but one of the colors isn't in the base colors set ðŸ« ");if(!this.allowDuplicates&&s.some((t,e)=>s.indexOf(t)!==e))throw new Error("Watch out, duplicate colors are not allowed in this game ðŸ¥¸");if(s.length!==this.columns)throw new Error("Mmmh... guess must have "+this.columns+" pins in it ðŸ¤”");if(this.board.some(t=>JSON.stringify(t)===JSON.stringify(s)))throw new Error("Sure ? You already tried this one ðŸ¤¨")}async setBoardRow(s,t){await this.checkGuessIsValid(t),this.board[s]||(this.board[s]=[]),this.board[s]=t}async setBoardRowAvailable(s){await this.checkGuessIsValid(s);let t=-1;for(let e=0;e<this.board.length;e++)if(this.board[e].every(i=>i===null)){t=e;break}if(t===-1&&this.board.length<this.rows&&(t=this.board.length,this.addBoardRow()),t!==-1)this.board[t]=s;else throw new Error("No empty row available")}sortByLeastCommonColors(s,t){return t.sort((e,i)=>{const o=this.countLeastCommonColors(s,e),l=this.countLeastCommonColors(s,i);return o-l})}sortBySamePosition(s,t){return t.sort((e,i)=>{const o=this.countSamePosition(s,e);return this.countSamePosition(s,i)-o})}}export{q as H,V as M};
